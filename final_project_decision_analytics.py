# -*- coding: utf-8 -*-
"""Final_Project_Decision_Analytics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JE-gy4gh9M5HH19Xk78D3EA3OFPCFX6p
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

rides = pd.read_csv('rideshare_kaggle.csv')

rides

rides.info()

surge = rides['surge_multiplier']

rides['surge_multiplier'] = 1
rides.head(100)

uber = rides[rides['cab_type'] == 'Uber']
lyft = rides[rides['cab_type'] == 'Lyft']

w = rides['short_summary']
w.value_counts()

uber['price'].describe()

lyft.info()



# prompt: hotspots from uber dataset on an actual map

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
#import plotly.express as px

rides = pd.read_csv('rideshare_kaggle.csv')
#rides
#rides.info()
uber = rides[rides['cab_type'] == 'Uber']
#lyft = rides[rides['cab_type'] == 'Lyft']
#uber.info()
#lyft.info()

# Assuming 'uber' DataFrame has 'latitude' and 'longitude' columns
uber_hotspots = uber.groupby(['latitude', 'longitude']).size().reset_index(name='counts')

# Sort by counts to find the most frequent locations
uber_hotspots = uber_hotspots.sort_values('counts', ascending=False)

# Display the top N hotspots (e.g., top 10)
print(uber_hotspots.head(10))

#For plotting on an actual map (requires a mapping library like folium or plotly):
# Install necessary library
!pip install folium

import folium

# Create a map centered around the average location
# map_center = [uber['latitude'].mean(), uber['longitude'].mean()]
# map_uber = folium.Map(location=map_center, zoom_start=12)

# Add markers for each hotspot
# for index, row in uber_hotspots.head(10).iterrows():  # Plot only top 10 for clarity
#     folium.CircleMarker(
#         location=[row['latitude'], row['longitude']],
#         radius=row['counts'] / 100,  # Adjust radius based on counts
#         color='blue',
#         fill=True,
#         fill_color='blue',
#         popup=f"Hotspot: {row['counts']} rides",
#     ).add_to(map_uber)

# Display the map
# map_uber

import folium
map_center = [uber['latitude'].mean(), uber['longitude'].mean()]
map_uber = folium.Map(location=map_center, zoom_start=5)


for index, row in uber_hotspots.head(10).iterrows():
     folium.CircleMarker(
         location=[row['latitude'], row['longitude']],
         radius=row['counts'] / 1000,
         color='blue',
         fill=True,
         fill_color='blue',
         popup=f"Hotspot: {row['counts']} rides",
     ).add_to(map_uber)

map_uber

# prompt: Create a couple of bar graphs from the rideshare csv file

import matplotlib.pyplot as plt
import seaborn as sns

# Calculate the average price for each ride type
average_prices = rides.groupby('name')['price'].mean()

# Create the bar plot
plt.figure(figsize=(12, 6))
sns.barplot(x=average_prices.index, y=average_prices.values)
plt.xlabel('Ride Type')
plt.ylabel('Average Price')
plt.title('Average Price per Ride Type')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.tight_layout()
plt.show()


# Calculate the number of rides for each cab type
cab_type_counts = rides['cab_type'].value_counts()

# Create the bar plot
plt.figure(figsize=(6, 6))
sns.barplot(x=cab_type_counts.index, y=cab_type_counts.values)
plt.xlabel('Cab Type')
plt.ylabel('Number of Rides')
plt.title('Number of Rides per Cab Type')
plt.show()

# prompt: Create more EDA analysis

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import folium


# 1. Distribution of Prices
plt.figure(figsize=(10, 6))
sns.histplot(rides['price'], kde=True)
plt.title('Distribution of Ride Prices')
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.show()

# 2. Relationship between Distance and Price
plt.figure(figsize=(10, 6))
sns.scatterplot(x='distance', y='price', data=rides, hue='cab_type', alpha=0.5)
plt.title('Relationship between Distance and Price')
plt.xlabel('Distance')
plt.ylabel('Price')
plt.show()


# 3.  Correlation Matrix for Numerical Features
numerical_features = rides.select_dtypes(include=np.number)
correlation_matrix = numerical_features.corr()

plt.figure(figsize=(10,8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of Numerical Features')
plt.show()


# 4.  Boxplot of Prices by Cab Type and Name
plt.figure(figsize=(12, 6))
sns.boxplot(x='cab_type', y='price', hue='name', data=rides)
plt.title('Price Distribution by Cab Type and Ride Name')
plt.show()

# prompt: Create a simulation based of uber and lyft that is depedant on the variables to see if a driver would cancel. Generarte it using the dataframes uber and lyft

import pandas as pd
import numpy as np

def simulate_cancellation(ride_data):
    """
    Simulates driver cancellations based on various factors.

    Args:
        ride_data (pd.DataFrame): DataFrame containing ride information.
                                  It should have columns like 'distance', 'price',
                                  'hour', 'name', 'cab_type', and others you find relevant.

    Returns:
        pd.DataFrame: The input DataFrame with an added 'cancellation' column
                      (True if canceled, False otherwise).
    """

    # Create a copy to avoid modifying the original DataFrame
    simulated_rides = ride_data.copy()

    # Initialize cancellations to False
    simulated_rides['cancellation'] = False


    # Example cancellation logic (customize based on your actual data and insights):

    # 1.  Distance: Drivers might be less likely to accept long rides
    simulated_rides.loc[simulated_rides['distance'] > 5, 'cancellation'] = np.where(np.random.rand(len(simulated_rides[simulated_rides['distance'] > 5])) < 0.1 , True, False)  # 10% chance of cancellation for longer rides

    # 2.  Price: Low prices might lead to more cancellations
    simulated_rides.loc[simulated_rides['price'] < 5, 'cancellation'] = np.where(np.random.rand(len(simulated_rides[simulated_rides['price'] < 5])) < 0.2 , True, False)  # 20% chance of cancellation for low-priced rides

    # 3.  Hour of the day:  Cancellation rates might vary during peak hours or late nights
    simulated_rides.loc[simulated_rides['hour'].between(17, 20), 'cancellation'] = np.where(np.random.rand(len(simulated_rides[simulated_rides['hour'].between(17, 20)])) < 0.15 , True, False)  # 15% chance during peak hour

    # 4.  Ride type and cab type (add more conditions here)
    simulated_rides.loc[(simulated_rides['name'] == 'UberXL') & (simulated_rides['cab_type'] == 'Uber'), 'cancellation'] = np.where(np.random.rand(len(simulated_rides[(simulated_rides['name'] == 'UberXL') & (simulated_rides['cab_type'] == 'Uber')])) < 0.25, True, False)


    # 5. Add other rules based on your domain knowledge, e.g., surge pricing, weather


    return simulated_rides


# Example Usage (assuming 'uber' and 'lyft' DataFrames are available):
uber_simulated = simulate_cancellation(uber)
# lyft_simulated = simulate_cancellation(lyft)

# Analyze simulated data:

# Example: Calculate the cancellation rate for each ride type
cancellation_rates = uber_simulated.groupby('name')['cancellation'].mean()
cancellation_rates


# Further analysis, visualizations, etc.

# prompt: Create a discrete simulation event using the dataframe rides. Mainly on how the weather would affect the price and what would the multiplier be to then find the total price and would the weather cause an affect on cancellation from the transportation services

def simulate_weather_impact(ride_data):
    """
    Simulates the impact of weather on ride prices and cancellations.

    Args:
        ride_data (pd.DataFrame): DataFrame containing ride information.

    Returns:
        pd.DataFrame: DataFrame with added 'weather_multiplier', 'total_price', and 'weather_cancellation' columns.
    """
    # Create a copy to avoid modifying the original DataFrame
    simulated_rides = ride_data.copy()

    # Simulate weather conditions (replace with actual weather data if available)
    np.random.seed(42)  # for reproducibility
    simulated_rides['weather'] = np.random.choice(['Sunny', 'Rainy', 'Snowy', 'Windy'], size=len(simulated_rides))

    # Define weather multipliers (adjust these values based on your analysis)
    weather_multipliers = {'Sunny': 1.0, 'Rainy': 1.2, 'Snowy': 1.5, 'Windy': 1.1}

    # Calculate weather multiplier
    simulated_rides['weather_multiplier'] = simulated_rides['weather'].map(weather_multipliers)

    # Calculate total price
    simulated_rides['total_price'] = simulated_rides['price'] * simulated_rides['weather_multiplier']

    # Simulate weather-related cancellations (adjust probabilities as needed)
    simulated_rides['weather_cancellation'] = False
    simulated_rides.loc[simulated_rides['weather'] == 'Snowy', 'weather_cancellation'] = np.where(np.random.rand(len(simulated_rides[simulated_rides['weather'] == 'Snowy'])) < 0.3, True, False)  # 30% cancellation in snow
    simulated_rides.loc[simulated_rides['weather'] == 'Rainy', 'weather_cancellation'] = np.where(np.random.rand(len(simulated_rides[simulated_rides['weather'] == 'Rainy'])) < 0.1, True, False)  # 10% cancellation in rain


    return simulated_rides


# Calculate the average total price for each weather condition


# Calculate the cancellation rate for each weather condition
cancellation_rates_by_weather = uber_weather_simulated.groupby('weather')['weather_cancellation'].mean()
print("\nCancellation rates by weather:")
cancellation_rates_by_weather

# Example usage (assuming 'uber' DataFrame is available):
uber_weather_simulated = simulate_weather_impact(uber)

# Analyze the results
uber_weather_simulated

average_total_price_by_weather = uber_weather_simulated.groupby('weather')['total_price'].mean()
print("\nAverage total price by weather:")
average_total_price_by_weather

cancellation_rates_by_weather = uber_weather_simulated.groupby('weather')['weather_cancellation'].mean()
print("\nCancellation rates by weather:")
cancellation_rates_by_weather

# prompt: now try to tell me what would be the costs of each unique drive using this event simulation. I need it to be for every row from the rides dataframe. The only columns I need are the ids, the weather, base cost, transportation cost and then the total cost. the base cost should different dependent on the weather

def calculate_costs(rides):
  """Calculates costs for each ride based on weather conditions."""

  # Create a copy to avoid modifying the original DataFrame
  rides_with_costs = rides.copy()

  # Define base costs based on weather
  base_costs = {
      'Sunny': 5,
      'Rainy': 7,
      'Snowy': 10,
      'Windy': 6
  }

  # Apply base cost based on weather
  rides_with_costs['base_cost'] = rides_with_costs['weather'].map(base_costs)

  # Assuming 'transportation_cost' is already available, otherwise calculate it here
  # Example calculation (replace with your actual calculation logic)
  # rides_with_costs['transportation_cost'] = rides_with_costs['distance'] * 2


  # Calculate total cost
  rides_with_costs['total_cost'] = rides_with_costs['base_cost'] + rides_with_costs['price']


  return rides_with_costs[['id', 'weather', 'base_cost', 'price', 'total_cost']]

# Example Usage
uber_weather_simulated = simulate_weather_impact(uber)
rides_with_calculated_costs = calculate_costs(uber_weather_simulated)
rides_with_calculated_costs

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(rides_with_calculated_costs['weather'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(rides_with_calculated_costs, x='total_cost', y='weather', inner='box', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

import pandas as pd
import numpy as np

# Load your dataset (replace with your file path)
df = pd.read_csv('rideshare_kaggle.csv')

# Sample average speed in mph
AVERAGE_SPEED = 30  # in miles per hour

# Weather conditions where drivers might decline rides
BAD_WEATHER = ['Rain', 'Snow', 'Fog']

# Function to determine driver availability based on weather
def is_driver_available(short_summary):
    """Returns True if driver is available based on weather."""
    return short_summary not in BAD_WEATHER

# Calculate total cost considering surge multiplier
df['total_cost'] = df['price'] * df['surge_multiplier']

# Calculate ride time in minutes
df['ride_time_minutes'] = (df['distance'] / AVERAGE_SPEED) * 60  # Convert hours to minutes

# Simulate whether a ride can happen based on weather
df['can_take_ride'] = df['short_summary'].apply(is_driver_available)

# Count rides that could not happen due to weather
unfulfilled_rides = df[~df['can_take_ride']].shape[0]

# Output results
fulfilled_rides = df['can_take_ride'].sum()
total_rides = len(df)

print(f"Total Rides: {total_rides}")
print(f"Fulfilled Rides: {fulfilled_rides}")
print(f"Unfulfilled Rides: {unfulfilled_rides}")
print("Sample Data:")
print(df[['source', 'destination', 'short_summary', 'can_take_ride', 'total_cost', 'ride_time_minutes']].head())

ride = df[['source', 'destination', 'short_summary', 'can_take_ride', 'total_cost', 'ride_time_minutes']]

ride

import pandas as pd
import numpy as np

# Load the dataset
df = pd.read_csv('rideshare_kaggle.csv')

# Sample average speed in mph
AVERAGE_SPEED = 30  # in miles per hour

# Weather conditions where drivers might decline rides
BAD_WEATHER = ['Rain', 'Snow', 'Fog']

# Function to determine driver availability based on weather
def is_driver_available(short_summary):
    """Returns True if driver is available based on weather."""
    return short_summary not in BAD_WEATHER

# Separate the dataset for Uber and Lyft
uber_df = df[df['cab_type'] == 'Uber']
lyft_df = df[df['cab_type'] == 'Lyft']

# Calculate total cost and ride time for Uber rides
uber_df['total_cost'] = uber_df['price'] * uber_df['surge_multiplier']
uber_df['ride_time_minutes'] = (uber_df['distance'] / AVERAGE_SPEED) * 60  # Convert hours to minutes
uber_df['can_take_ride'] = uber_df['short_summary'].apply(is_driver_available)

# Calculate total cost and ride time for Lyft rides
lyft_df['total_cost'] = lyft_df['price'] * lyft_df['surge_multiplier']
lyft_df['ride_time_minutes'] = (lyft_df['distance'] / AVERAGE_SPEED) * 60  # Convert hours to minutes
lyft_df['can_take_ride'] = lyft_df['short_summary'].apply(is_driver_available)

# Count unfulfilled rides for Uber and Lyft
uber_unfulfilled = uber_df[~uber_df['can_take_ride']].shape[0]
lyft_unfulfilled = lyft_df[~lyft_df['can_take_ride']].shape[0]

# Count fulfilled rides for Uber and Lyft
uber_fulfilled = uber_df['can_take_ride'].sum()
lyft_fulfilled = lyft_df['can_take_ride'].sum()

# Total rides for Uber and Lyft
total_uber_rides = len(uber_df)
total_lyft_rides = len(lyft_df)

# Output Uber and Lyft results
uber_summary = {
    'Total Uber Rides': total_uber_rides,
    'Fulfilled Uber Rides': uber_fulfilled,
    'Unfulfilled Uber Rides': uber_unfulfilled
}

lyft_summary = {
    'Total Lyft Rides': total_lyft_rides,
    'Fulfilled Lyft Rides': lyft_fulfilled,
    'Unfulfilled Lyft Rides': lyft_unfulfilled
}

# Display sample data for both Uber and Lyft
uber_sample = uber_df[['source', 'destination', 'short_summary', 'can_take_ride', 'total_cost', 'ride_time_minutes']].head()
lyft_sample = lyft_df[['source', 'destination', 'short_summary', 'can_take_ride', 'total_cost', 'ride_time_minutes']].head()

# Print the results
print("Uber Summary:", uber_summary)
print("Lyft Summary:", lyft_summary)
print("\nSample Uber Rides:")
print(uber_sample)
print("\nSample Lyft Rides:")
print(lyft_sample)

import pandas as pd
import numpy as np

# Load the dataset
df = pd.read_csv('rideshare_kaggle.csv')

# Sample average speed in mph
AVERAGE_SPEED = 30  # in miles per hour

# Weather conditions with cancellation probabilities (could be expanded based on your needs)
WEATHER_PROBABILITY = {
    'Clear': 0.0,             # 0% chance of cancellation
    'Mostly Cloudy': 0.1,     # 10% chance of cancellation
    'Partly Cloudy': 0.2,     # 20% chance of cancellation
    'Overcast': 0.3,          # 30% chance of cancellation
    'Light Rain': 0.5,        # 50% chance of cancellation
    'Rain': 0.9,              # 70% chance of cancellation
    'Possible Drizzle': 0.4,  # 40% chance of cancellation
    'Foggy': 0.6,             # 60% chance of cancellation
    'Drizzle': 0.5            # 50% chance of cancellation
}

# Function to determine if the ride will happen based on weather and probability
def can_take_ride(short_summary):
    """Simulate if the driver can take the ride based on weather and cancellation probability."""
    cancel_prob = WEATHER_PROBABILITY.get(short_summary, 0.0)  # Default to 0% if weather not in dictionary
    # Simulate whether the ride can happen
    return np.random.rand() > cancel_prob

# Separate the dataset for Uber and Lyft
uber_df = df[df['cab_type'] == 'Uber']
lyft_df = df[df['cab_type'] == 'Lyft']

# Calculate total cost and ride time for Uber rides
uber_df['total_cost'] = uber_df['price'] * uber_df['surge_multiplier']
uber_df['ride_time_minutes'] = (uber_df['distance'] / AVERAGE_SPEED) * 60  # Convert hours to minutes
uber_df['can_take_ride'] = uber_df['short_summary'].apply(can_take_ride)

# Calculate total cost and ride time for Lyft rides
lyft_df['total_cost'] = lyft_df['price'] * lyft_df['surge_multiplier']
lyft_df['ride_time_minutes'] = (lyft_df['distance'] / AVERAGE_SPEED) * 60  # Convert hours to minutes
lyft_df['can_take_ride'] = lyft_df['short_summary'].apply(can_take_ride)

# Count unfulfilled rides for Uber and Lyft
uber_unfulfilled = uber_df[~uber_df['can_take_ride']].shape[0]
lyft_unfulfilled = lyft_df[~lyft_df['can_take_ride']].shape[0]

# Count fulfilled rides for Uber and Lyft
uber_fulfilled = uber_df['can_take_ride'].sum()
lyft_fulfilled = lyft_df['can_take_ride'].sum()

# Total rides for Uber and Lyft
total_uber_rides = len(uber_df)
total_lyft_rides = len(lyft_df)

# Output Uber and Lyft results
uber_summary = {
    'Total Uber Rides': total_uber_rides,
    'Fulfilled Uber Rides': uber_fulfilled,
    'Unfulfilled Uber Rides': uber_unfulfilled
}

lyft_summary = {
    'Total Lyft Rides': total_lyft_rides,
    'Fulfilled Lyft Rides': lyft_fulfilled,
    'Unfulfilled Lyft Rides': lyft_unfulfilled
}

# Display sample data for both Uber and Lyft
uber_sample = uber_df[['source', 'destination', 'short_summary', 'can_take_ride', 'total_cost', 'ride_time_minutes']]
lyft_sample = lyft_df[['source', 'destination', 'short_summary', 'can_take_ride', 'total_cost', 'ride_time_minutes']]

# Print the results
print("Uber Summary:", uber_summary)
print("Lyft Summary:", lyft_summary)
print("\nSample Uber Rides:")
print(uber_sample)
print("\nSample Lyft Rides:")
print(lyft_sample)

uber_sample

lyft_sample

import pandas as pd
import numpy as np
import folium

# Load the dataset
df = pd.read_csv('rideshare_kaggle.csv')

# Sample average speed in mph
AVERAGE_SPEED = 30  # in miles per hour

# Weather conditions with cancellation probabilities (could be expanded based on your needs)
WEATHER_PROBABILITY = {
    'Clear': 0.0,             # 0% chance of cancellation
    'Mostly Cloudy': 0.1,     # 10% chance of cancellation
    'Partly Cloudy': 0.2,     # 20% chance of cancellation
    'Overcast': 0.3,          # 30% chance of cancellation
    'Light Rain': 0.5,        # 50% chance of cancellation
    'Rain': 0.7,              # 70% chance of cancellation
    'Possible Drizzle': 0.4,  # 40% chance of cancellation
    'Foggy': 0.6,             # 60% chance of cancellation
    'Drizzle': 0.5            # 50% chance of cancellation
}

# Function to determine if the ride will happen based on weather and probability
def can_take_ride(short_summary):
    """Simulate if the driver can take the ride based on weather and cancellation probability."""
    cancel_prob = WEATHER_PROBABILITY.get(short_summary, 0.0)  # Default to 0% if weather not in dictionary
    # Simulate whether the ride can happen
    return np.random.rand() > cancel_prob

# Separate the dataset for Uber and Lyft
uber_df = df[df['cab_type'] == 'Uber']
lyft_df = df[df['cab_type'] == 'Lyft']

# Calculate total cost and ride time for Uber rides
uber_df['total_cost'] = uber_df['price'] * uber_df['surge_multiplier']
uber_df['ride_time_minutes'] = (uber_df['distance'] / AVERAGE_SPEED) * 60  # Convert hours to minutes
uber_df['can_take_ride'] = uber_df['short_summary'].apply(can_take_ride)

# Calculate total cost and ride time for Lyft rides
lyft_df['total_cost'] = lyft_df['price'] * lyft_df['surge_multiplier']
lyft_df['ride_time_minutes'] = (lyft_df['distance'] / AVERAGE_SPEED) * 60  # Convert hours to minutes
lyft_df['can_take_ride'] = lyft_df['short_summary'].apply(can_take_ride)

# Count unfulfilled rides for Uber and Lyft
uber_unfulfilled = uber_df[~uber_df['can_take_ride']].shape[0]
lyft_unfulfilled = lyft_df[~lyft_df['can_take_ride']].shape[0]

# Count fulfilled rides for Uber and Lyft
uber_fulfilled = uber_df['can_take_ride'].sum()
lyft_fulfilled = lyft_df['can_take_ride'].sum()

# Total rides for Uber and Lyft
total_uber_rides = len(uber_df)
total_lyft_rides = len(lyft_df)

# Output Uber and Lyft results
uber_summary = {
    'Total Uber Rides': total_uber_rides,
    'Fulfilled Uber Rides': uber_fulfilled,
    'Unfulfilled Uber Rides': uber_unfulfilled
}

lyft_summary = {
    'Total Lyft Rides': total_lyft_rides,
    'Fulfilled Lyft Rides': lyft_fulfilled,
    'Unfulfilled Lyft Rides': lyft_unfulfilled
}

# Display sample data for both Uber and Lyft
uber_sample = uber_df[['source', 'destination', 'short_summary', 'can_take_ride', 'total_cost', 'ride_time_minutes', 'latitude', 'longitude']].head()
lyft_sample = lyft_df[['source', 'destination', 'short_summary', 'can_take_ride', 'total_cost', 'ride_time_minutes', 'latitude', 'longitude']].head()

# Print the results
print("Uber Summary:", uber_summary)
print("Lyft Summary:", lyft_summary)
print("\nSample Uber Rides:")
print(uber_sample)
print("\nSample Lyft Rides:")
print(lyft_sample)

